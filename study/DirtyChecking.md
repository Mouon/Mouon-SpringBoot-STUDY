# 더티체킹에대한 고민

###### JPA를 사용하면 영속성 컨텍스트를 활용하게되고, 그 안에서 다양한 기능들을 사용하게 된다.  
###### 그 중에서도 더티 체킹은 JPA의 강력한 기능 중 하나로, 엔티티 상태 변화를 자동으로 관리할 수 있게 해준다.  
###### 이번글에서는 더티체킹에대한 짧은 고민과 나름대로의 정리를 해보려고 한다.  

더티 체킹이란 JPA의 영속성 컨텍스트가 엔티티의 상태를 지속적으로 추적하여 객체를 추적하여 상태 변경을 감지하면, 트랜잭션이 커밋될때 직접 수정 쿼리를 작성하지않아도 
자동으로 업데이트를 쿼리를 날려주는 기능이다.  
때문에 실제 비즈니스로직에서 엔티티에대한 수정작업을 구현할때 사용할 수 있다.  
또한 직접 수정 쿼리를 날리는 것 보다. 엔티티를 더 객체지향에 맞게 다룰 수 있게된다.  

그래서 나는 실제 프로젝트에서 스터디룸 삭제(논리적이 삭제 = 상태 변경)와 같은 기능을 구현하는데에 더티체킹을 이용했다.  
그러나 별로 의식하지는 않았지만, 다수의 업데이트가 필요한 경우에는 사용하지 않고있었다.  

하지만 JPA를 더 깊게알 알아보고 싶은 마음에 JPA 강의를 듣던 중  

다수의 업데이트가 필요한 경우에는 왜 더티 체킹을 이용하지 않았지라는 고민이 발생하며, 더티체킹으로 구현하려고 코드를 검토하던 중 이유가 명확해졌다.  

다수의 업데이트가 필요한 경우 더티 체킹을 이용하려면 엔티티를 모두 조회하여 메모리에 로드해야한다. 그런 다음 메모리 상의 객체들의 작업을 순회해야한다.  
이러면 데이터가 아주 많을 경우 메모리가 부하될 수 있고, 데이터베이스와의 다수의 통신이 발생하기떄문에 성능도 저하 될 것이다.  

그래서 나는 다수의 객체에대한 수정이라는 요구사항이 있을 경우에는 벌크연산을 통해 직접 수정해야한다는 생각이 들었다.

### 그렇다면 더티체킹은 언제쓰지?

"그렇다면 더티체킹은 언제쓰지?"라는 고민도 동시에 생겼다. 더티체킹은 ORM을 좀 더 객체 지향적으로 사용 할 수 있게해주는 좋은 기능이면서 편리한 기능이다.  

따라서 고민을 하던중 더티체킹은 "단건 수정"혹은 엔티티 수가 많지 않은 경우에만 사용해야겠다는 결론이 들었다.  

  
### 고민 적용

실제 프로젝트에서 고민을 적용해보았다.  
아래는 유저가 스터디룸을 삭제하는 기능이다. 스터디룸을 삭제하면 스터디룸 삭제는 물론 관련 데이터까지 모두 삭제가 되어야한다.
```java
    @Transactional
    public void deleteStudyroom(long studyroomId, long memberId) {
        if (validateMemberRole(studyroomId,memberId,MemberRole.CAPTAIN)) {
            try {
                memberstudyroomRepository.deleteMemberStudyroom(studyroomId, BaseStatus.DELETE);
                dataRepository.updateDataStatus(studyroomId,BaseStatus.DELETE);
                studyroomRepository.updateStudyroomStatus(studyroomId, BaseStatus.DELETE);
            }catch (Exception e){
                //예외처리
            }
        } else {
                //예외처리
        }
    }
```

이 경우에는 모두 벌크 연산을 사용했다. 스터디룸에 업로드된 파일, 스터디원 등은 다수의 업데이트가 필요하다.  
스터디원을 인원제한으로 그 숫자가 적을 수는 있지만, 업로드된 파일의 경우 수백건을 넘길 수 있다.  
이경우 JPA를 통해 엔티티를 모두 메모리에 로드한다면 그자체로 메모리에 큰 부담일 것이다.  
또한 더티체킹을 통해 쿼리가 각각 발생한다면 DB 통신이 다수 발생해 성능상 큰 문제가 생길 것이다.  
따라서 더티 체킹이 아닌 벌크연산을 선택했다.  

### studyroom은 단건인데?

그렇다, studyroom을 삭제하는것은 단건이다. 하지만 이 경우에는 더티체킹을 위해 스터디룸의 모든 정보를 메모리에 로드하는 것은 메모리와 성능 측면에서 추가적인 리소스를 소모한다고
 판단하여 이또한 직접 쿼리를 이용하였다.

개발을 하면 할수록 모든 방법에는 장단점이있고 정답이 없는 고민의 연속인 것같다.  
이번 고민을 통해 ORM과 영속성 컨텍스트에 관련된 나의 지식의 도구가 한층 더 정리된 것같다.