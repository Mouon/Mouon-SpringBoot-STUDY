# 🚀 스터디룸 데이터 조회 성능 개선기


오늘은 최근에 겪은 데이터베이스 최적화 여정을 기록하려고 한다.  
이 기록의 시작점은 스터디룸에서 데이터 리스트를 조회하는 무한 스크롤 기능의 성능 개선이다.  
우리 서비스의 스터디룸 기능에서는 사용자들이 다양한 데이터를 조회할 수 있다.  
특히 커서 기반의 무한 스크롤을 구현하면서 페이지네이션 성능이 중요해졌기 때문에 
해당 기능을 인덱스를 추가해서 개선해보기로 했다.  

### 상황 분석

우선 문제를 해결하기 위해 조회 요청시 발생하는 쿼리를 살펴보았다.  

```sql
select
  d1_0.data_id,
  d1_0.data_name,
  d1_0.data_url,
  d1_0.og_title,
  d1_0.og_description,
  d1_0.og_image,
  d1_0.og_url,
  d1_0.og_type
from
  data d1_0
where
  d1_0.studyroom_id=?
  and d1_0.data_type=?
  and d1_0.status=?
order by
  d1_0.data_id desc
limit
  ?
```

이 쿼리의 성능을 정확히 측정하기 위해 10만 개의 HTTP 요청으로 테스트를 진행하기로 했다.  


### 🏃🏻첫 번째 시도: 인덱스 없이 
처음에는 아무런 인덱스 없이 쿼리를 실행해 보았다. 결과는 다음과 같았다:
![첫시도.png](%EC%B2%AB%EC%8B%9C%EB%8F%84.png)  
- 평균 응답 시간: 916 ms
- 최대 응답 시간: 3970 ms
- 표준 편차: 435.29 ms
- 처리량: 1056.9/초



첫 테스트 이후 쿼리 튜닝을 위해 인덱스를 만드는 작업을 진행했다.  
인덱스는 조회때 발생하는 쿼리를 기준으로 만들었는데 쿼리를 살펴보면 
`studyroom_id`, `data_type`, `status` 를 기준으로 쿼리가 발생하고 있었기 때문에  
WHERE 절에 사용된 컬럼으로 인덱스를 만들어 테스트 해보기로 하였다.  

### 🤔 두 번째 시도: WHERE 절만 고려한 인덱스
문제 해결을 위해 WHERE 절에 사용된 컬럼으로 인덱스를 만들어 보았다:

```sql

CREATE INDEX idx_data_studyroom_type_status
ON data (studyroom_id, data_type, status);

```

그러나 결과는 기대와 달랐다:
![두번째.png](%EB%91%90%EB%B2%88%EC%A7%B8.png)  

- 평균 응답 시간: 968 ms (오히려 증가!)
- 최대 응답 시간: 4625 ms (더 증가!!)
- 표준 편차: 523.92 ms (변동성 증가)
- 처리량: 1000.4/초 (감소)

성능이 개선되기는커녕 오히려 나빠졌다. 무언가 놓친 것이 분명했다....

다시 쿼리를 살펴보았다..

```sql
select
  d1_0.data_id,
  d1_0.data_name,
  d1_0.data_url,
  d1_0.og_title,
  d1_0.og_description,
  d1_0.og_image,
  d1_0.og_url,
  d1_0.og_type
from
  data d1_0
where
  d1_0.studyroom_id=?
  and d1_0.data_type=?
  and d1_0.status=?
order by
  d1_0.data_id desc
limit
  ?
```

쿼리르 다시 보니 필터링 후에 놓진 것이 있었다. 비로 `data_id` 였다. 
필터링 기준에만 집중한 나머지 조회후 `data_id` 기준으로 정렬한다는것을 놓지고있었다..

### 💡 세 번째 시도: ORDER BY를 고려한 인덱스
고민 끝에 ORDER BY 절도 인덱스에 포함해야 한다는 것을 깨달았다. 그래서 이번에는 다음과 같이 인덱스를 만들었다:

```sql
CREATE INDEX idx_studyroom_data_status_id
ON data (data_id DESC, studyroom_id, data_type, status);

```

![세번째.png](%EC%84%B8%EB%B2%88%EC%A7%B8.png)  

결과는 다음과 같았다:

- 평균 응답 시간: 810 ms (11.6% 개선)
- 최대 응답 시간: 2866 ms (27.8% 개선)
- 표준 편차: 309.09 ms (29% 개선)
- 처리량: 1197.0/초 (13.3% 증가)

드디어 눈에 띄는 성능 향상이 이루어졌다!!!  
응답 시간은 더 빠르고 안정적이 되었으며, 처리량도 크게 증가했다.  
  

  
## 더 나아가서...

나의 개선 과정을 보며 왜 인덱스를 모든 select컬럼 기준으로 안만드냐라는 의문이 생길 수 있다.
이는 인덱스의 재사용성을 고려한 결정이었다. 모든 SELECT 컬럼을 포함하면 이 특정 쿼리에는 완벽할 수 있지만,  
인덱스가 너무 특화되어 다른 쿼리에서 활용하기 어려워지고 유지보수 비용도 증가한다.  
대신 WHERE 절과 ORDER BY에 사용되는 컬럼만으로 인덱스를 구성하면, 다양한 쿼리에서 이 인덱스를 재사용할 수 있다.  

무엇보다 이글에서는 DB 관점에서 자세히 다루지는 않았지만 인덱스를 통한 쿼리튜닝이란 것이  
단순하게 WHERE 절과 ORDER BY를 고려한다고해서 뜻대로 쿼리가 인덱스를 타지 않을 수 있다.
DB의 옵티마이저가 효율적인 인덱스를 자동으로 선택하거나, 여러 탐색전략을 자동으로 세우는데,  
인덱스를 구성하는 컬럼의 순서나 구성요소 등의 영향을 받아 생성한 인덱스를 타지않거나 일부만 타는 일이 발생할 수 있다.  

설명이 어려워질까봐 위에서 소개하지는 않았지만 개선 과정에서 단순 응답시간만을 기준으로 인덱스를 개선한 것은 아니었다.  
물론 응답시간이 인덱스가 잘못구성 되었음의 중요한 단서이긴하지만 `쿼리 실행계획`을 먼저 살펴보는 것이 좋은 접근 방법일 것이다.  
실제로 아래의 인덱스에서는 쿼리 실행시 추가적인 `file sort`가 발생하는 비효율적인 면이있었다.
```sql

CREATE INDEX idx_data_studyroom_type_status
ON data (studyroom_id, data_type, status);

```

그렇지만 개선을 경험한 아래 인덱스는 쿼리 실행계획을 살펴보았을때 추가적인 작업 없이 100% 인덱스를 활용하고있었다.  
```sql

CREATE INDEX idx_studyroom_data_status_id
ON data (data_id DESC, studyroom_id, data_type, status);

```
![쿼리실행계획.png](%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D.png)

### 스프링에서 인덱스 명시

인덱스를 만들었다면 동료 개발자들이나 미래의 내가 쿼리를 작성할때 인덱스를 염두할 수 있도록 명시해주도록하자! (실제 인덱스는 DB에서 직접만들지만!)  
```java
@Table(indexes = {
    @Index(name = "idx_studyroom_data_status_id", columnList = "studyroom_id, data_type, status, data_id")
})
```


## 🚀 결론
이번 최적화를 통해 무한 스크롤의 성능을 개선할 수 있었다.  
처음에는 단순히 WHERE 절만 고려했다가 오히려 성능이 악화되는 경험을 했지만,   
ORDER BY까지 고려한 인덱스 설계로 만족스러운 성능 향상을 이루어냈다.

이번에 배운 중요한 것은 단순히 인덱스를 추가하는 것이 아니라,  
쿼리의 전체적인 동작을 이해하고 이에 맞는 전략을 수립해야한다는 것이다.  
WHERE 절만 고려할 것이 아니라
ORDER BY, 그리고 더 나아가서 SELECT 목록까지 모두 고려해야 하며,  
동시에 인덱스의 재사용성도 염두에 두어야 한다.
또한 쿼리 실행계획을 모니터링하며 인덱스 구성을 조정해야한다.  

이 경험을 통해 인덱스의 위력(?)을 체감할 수 있었던 좋은 경험이었던 것 같다!!!
다음글에서는 인덱스 자체에 집중하는 기록을 해보아애겠다.



