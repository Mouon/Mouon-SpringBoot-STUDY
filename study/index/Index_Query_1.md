# 🚀 스터디룸 데이터 조회 성능 개선기


오늘은 최근에 겪은 데이터베이스 최적화 여정을 기록하려고 한다.  
이 기록의 시작점은 스터디룸에서 데이터 리스트를 조회하는 무한 스크롤 기능의 성능 개선이다.  
우리 서비스의 스터디룸 기능에서는 사용자들이 다양한 데이터를 조회할 수 있다.  
특히 커서 기반의 무한 스크롤을 구현하면서 페이지네이션 성능이 중요해졌기 때문에 
해당 기능을 인덱스를 추가해서 개선해보기로 했다.  

### 상황 분석

우선 문제를 해결하기 위해 조회 요청시 발생하는 쿼리를 살펴보았다.  

```sql
select
  d1_0.data_id,
  d1_0.data_name,
  d1_0.data_url,
  d1_0.og_title,
  d1_0.og_description,
  d1_0.og_image,
  d1_0.og_url,
  d1_0.og_type
from
  data d1_0
where
  d1_0.studyroom_id=?
  and d1_0.data_type=?
  and d1_0.status=?
order by
  d1_0.data_id desc
limit
  ?
```

이 쿼리의 성능을 정확히 측정하기 위해 10만 개의 HTTP 요청으로 테스트를 진행하기로 했다.  


### 🏃🏻첫 번째 시도: 인덱스 없이 
처음에는 아무런 인덱스 없이 쿼리를 실행해 보았다. 결과는 다음과 같았다:
![첫시도.png](%EC%B2%AB%EC%8B%9C%EB%8F%84.png)  
- 평균 응답 시간: 916 ms
- 최대 응답 시간: 3970 ms
- 표준 편차: 435.29 ms
- 처리량: 1056.9/초



첫 테스트 이후 쿼리 튜닝을 위해 인덱스를 만드는 작업을 진행했다.  
인덱스는 조회때 발생하는 쿼리를 기준으로 만들었는데 쿼리를 살펴보면 
`studyroom_id`, `data_type`, `status` 를 기준으로 쿼리가 발생하고 있었기 때문에  
WHERE 절에 사용된 컬럼으로 인덱스를 만들어 테스트 해보기로 하였다.  

### 🤔 두 번째 시도: WHERE 절만 고려한 인덱스
문제 해결을 위해 WHERE 절에 사용된 컬럼으로 인덱스를 만들어 보았다:

```sql
CREATE INDEX idx_data_main
ON data (studyroom_id, data_type, status);

```

그러나 결과는 기대와 달랐다:
![두번째.png](%EB%91%90%EB%B2%88%EC%A7%B8.png)  

- 평균 응답 시간: 968 ms (오히려 증가!)
- 최대 응답 시간: 4625 ms (더 증가!!)
- 표준 편차: 523.92 ms (변동성 증가)
- 처리량: 1000.4/초 (감소)

성능이 개선되기는커녕 오히려 나빠졌다. 무언가 놓친 것이 분명했다....

다시 쿼리를 살펴보았다..

```sql
select
  d1_0.data_id,
  d1_0.data_name,
  d1_0.data_url,
  d1_0.og_title,
  d1_0.og_description,
  d1_0.og_image,
  d1_0.og_url,
  d1_0.og_type
from
  data d1_0
where
  d1_0.studyroom_id=?
  and d1_0.data_type=?
  and d1_0.status=?
order by
  d1_0.data_id desc
limit
  ?
```

쿼리르 다시 보니 필터링 후에 놓진 것이 있었다. 비로 `data_id` 였다. 
필터링 기준에만 집중한 나머지 조회후 `data_id` 기준으로 정렬한다는것을 놓지고있었다..

### 💡 세 번째 시도: ORDER BY를 고려한 인덱스
고민 끝에 ORDER BY 절도 인덱스에 포함해야 한다는 것을 깨달았다. 그래서 이번에는 다음과 같이 인덱스를 만들었다:

```sql
CREATE INDEX idx_data_main ON data 
(studyroom_id, data_type, status, data_id DESC);

```

![세번째.png](%EC%84%B8%EB%B2%88%EC%A7%B8.png)  

결과는 다음과 같았다:

- 평균 응답 시간: 810 ms (11.6% 개선)
- 최대 응답 시간: 2866 ms (27.8% 개선)
- 표준 편차: 309.09 ms (29% 개선)
- 처리량: 1197.0/초 (13.3% 증가)

드디어 눈에 띄는 성능 향상이 이루어졌다!!!  
응답 시간은 더 빠르고 안정적이 되었으며, 처리량도 크게 증가했다.  
  

  


나의 개선 과정을 보며 왜 인덱스를 모든 select컬럼 기준으로 안만드냐라는 의문이 생길 수 있다.
이는 인덱스의 재사용성을 고려한 결정이었다. 모든 SELECT 컬럼을 포함하면 이 특정 쿼리에는 완벽할 수 있지만,  
인덱스가 너무 특화되어 다른 쿼리에서 활용하기 어려워지고 유지보수 비용도 증가한다.(인덱스 남용은 DB에서 삽입 작업에서의 성능 저하를 유발한다.)  
대신 자주 조회하는 컬럼만으로 인덱스를 구성하면, 다양한 쿼리에서 이 인덱스를 재사용할 수 있다.(예시 기준 status와 studyroom_id, data_id, type 은 다른 조회 기능에서도 포함될 가능성이 매우 높은 칼럼들이다.)  

## 🚀 결론
이번 최적화를 통해 무한 스크롤의 성능을 개선할 수 있었다.  
처음에는 단순히 WHERE 절만 고려했다가 오히려 성능이 악화되는 경험을 했지만,   
ORDER BY까지 고려한 인덱스 설계로 만족스러운 성능 향상을 이루어냈다.

이번에 배운 중요한 것은 단순히 인덱스를 추가하는 것이 아니라,  
쿼리의 전체적인 동작을 이해하고 이에 맞는 전략을 수립해야한다는 것이다.  
WHERE 절만 고려할 것이 아니라
ORDER BY, 그리고 더 나아가서 SELECT 목록까지 모두 고려해야 하며,  
동시에 인덱스의 재사용성도 염두에 두어야 한다.

이 경험을 통해 인덱스의 위력(?)을 체감할 수 있었던 좋은 경험이었던 것 같다!!!



