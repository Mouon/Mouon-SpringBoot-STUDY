# Restful한 API 와 API 설계에대한 고민 - 1탄

이 글은 깊이있는 API의 설계 (보안, 버전 관리)보다는 개발시의 커뮤니티 관점에 아주 조금 무게를 두어 API를 다뤄보려한다.

백엔드 개발을하면 당현히 API 를 만들게된다. API란 프로그램끼리의 통신수단이라고 볼 수 있다.  
어렵게말하면.. 두 개 이상의 소프트웨어 애플리케이션이 서로 통신할 수 있게 해주는 인터페이스라고 볼 수 있다.  

API 는 주로 HTTP통신 규약에따라 주고받아지게 된다.  
이때 가장 흔히 사용되는 API유형이 RestAPI인 것이다. 당연하게도 Rest는 줄임말이다. 이 줄임말을 풀어보면 "Representational State Transfer" 라고 한다.  
그렇다 이름에서 알 수 있듯이 REST는 리소스의 상태와 그 상태를 전송하는 방법을 규정하는 아키텍처 스타일이다.

“RESTful 하다”라는 표현은 API가 REST 아키텍처 스타일의 원칙과 규칙을 따르고 있다는 것을 의미한다.
“RESTful 하다”의 특성으로는 다음과같은 특성이있다. ( 대표적인 것 만 적어보겠다... ) 

- 리소스 중심:  
API의 모든 기능은 리소스(데이터 객체나 서비스)와 관련되어야한다.
- HTTP 메서드 사용:  
  리소스에 대한 작업은 HTTP 메서드를 통해 수행되어야한다. (GET,PUT,POST,PATCH,DELETE 이런것을 각 목적에 맞게 지켜야한다!)
- 무상태성 (Stateless):  
각 요청은 독립적이며, 서버는 상태를 저장하지 않아야한다. 
모든 요청에는 필요한 모든 정보가 포함되어야 하며, 
서버는 요청을 처리하기 위해 상태를 기억할 필요가없다.
- 표준화된 인터페이스:  
명세서 작성 등을 통해 명세화를 하여 관리하고, URI형태는 예층 가능 해야하며, 
정형화된 JSON응답 형식으로 작성되어야한다.

#### 여기서 무상태성 (Stateless)이 중요하기도하고 조금은 와닿지 않을 수 있기때문에 한번 더 정리하자면..

사용자가 상품을 주문할 때 요청에 포함되는 정보가 있을때 이 정보를 모두 포함해서 전송해야한다는 것이다
```json
{
  "user_id": "1",
  "product_id": "1",
  "quantity": 7,
  "address": "서울시 광진구"
}
```

서버는 이 요청만을 기반으로 주문을 처리하고
서버는 이전에 이 사용자가 무엇을 주문했는지 기억해서 사용하지 않는다는 것다! 그래서 다음 주문요청시에도 아래같이 모든 정보를 담아 요창해야한다!

```json
{
  "user_id": "1",
  "product_id": "1",
  "quantity": 17,
  "address": "서울시 광진구"
}
```

위의 특성이외에도 다양한 상황을 예측하여 보안성이 좋은 API를 설계하는 것도 중요하다.
대표적인 보안방법으로는 JWT라는 토큰 기반 인증 방식이 있다.


### 이제 원칙적인 이야기보다는 좀더 개발 상황에 가까운 측면에서 API 설계에대한 이야기를 해보자

RESTful API의 원칙을 준수하면서도 프로젝트의 여러 요구사항을 충족시키는 것은 어려운점이다.
예를 들어 클라이언트의 요청은 간단할 수 있지만, 
서버 측에서는 다양한 상황을 처리할 수 있는 유연성과 확장성을 고려해야 한다.

## 응답 구조와 효율성
클라이언트가 요구하는 API는 간단하고 직관적일 수 있지만, 
서버 측에서는 API의 확장성과 유지보수, 성능 등을 고려해야한다. 
이로 인해 클라이언트가 받을 수 있는 응답이 때로는 복잡하거나 비효율적일 수 있다. 

응답 형식 설계를 예로 들어보겠다.

#### 단순 객체 응답

클라이언트가 특정 리소스를 조회할 때, 서버가 단일 객체를 반환할 수 있다.

- **요청**: `GET /users/1`
- **응답**:
  ```json
  {
    "id": 1,
    "name": "Jeff Dean",
    "email": "JeffDean@gmail.com"
  }
  ```

이 경우에는 클라이언트는 단일 사용자의 정보를 간단하게 받아볼 수 있다.
서버와 클라이언트 양측모두 논쟁의 여지가없다.

#### 리스트 객체 응답

리소스 목록을 반환할 때, 서버는 객체 배열을 반환할 수 있다.

- **요청**: `GET /users`
- **응답**:
    ```json
    [
      {
        "id": 1,
        "name": "Jeff Dean",
        "email": "JeffDean@gmail.com"
      },
      {
        "id": 2,
        "name": "Alpha",
        "email": "Alpha@gmail.com"
      }
    ]
    ```

이 경우 클라이언트는 사용자 목록을 배열 형태로 간단하게 받을 수 있다.
그러나 리소스 목록을 단순히 배열 형태로 반환하는 것은 빠르고 간단하지만, 
API의 확장성과 유연성을 제한할 수 있다. (API 스펙이 닫혀버린다.)
이로 인해 추가적인 정보를 포함하거나 API를 확장할 때 어려움을 겪을 수 있다.
특히, 리스트 응답에 추가적인 메타데이터나 관련 정보를 포함해야 할 경우, 단순 배열 구조는 그 자체로 제약이 되어버린다.
클라이언트의 요구사항은 언제든지 변할 수 있고, 그 점을 염두하고 API를 설계해야한다.

위 API에서 클라이언트가 요청을 보낸 유저정보를 필요로 하게 되었다고 가정해보자,
이때 응답이 DTO 리스트라면 추가적인 데이터를 넣는것이 까다로울것이다.
하지만 DTO객체 내부에 별도의 리스트로써 응답을 구성했다면 
필드만 추가하는 간단한 수정으로 클라이언트 요구 사항을 반영할 수 있을것이다.

아래는 리스트를 객체로 한번 감싸 여러 추가적인 데이터를 넣는 예시이다.

- **요청**: `GET /users/1`
- **응답**:
  ```json
  {
    "id": 1,
    "name": "Jeff Dean",
    "email": "JeffDean@gmail.com",
    "userList": [
      {
        "id": 1,
        "name": "Jeff Dean",
        "email": "JeffDean@gmail.com"
      },
      {
        "id": 2,
        "name": "Alpha",
        "email": "Alpha@gmail.com"
      }
    ]
  }
  ```

## 결론 : API 균형잡기
API 설계는 클라이언트와 서버 간의 지속적인 대화와 조율의 결과물이어야 한다. 
클라이언트의 요구사항을 경청하되, 서버의 제약사항과 장기적인 유지보수성을 고려하여 균형 잡힌 접근 방식을 취해야 한다. 
이를 통해 현재의 요구사항을 충족하면서도 미래의 변화에 유연하게 대응할 수 있는 강력하고 지속 가능한 API를 구축할 수 있도록 개발하는것이 중요하다고 생각한다.